@inherits TestComponentBase

<Fixture Test="CallingGetMultipleTimesReturnsSameInstance">
	<ComponentUnderTest>
		<Wrapper>CUT</Wrapper>
	</ComponentUnderTest>
	<Fragment Id="first">first</Fragment>
	<Fragment Id="second">
		<Wrapper>second</Wrapper>
	</Fragment>
</Fixture>
@code{
	void CallingGetMultipleTimesReturnsSameInstance(Fixture f)
	{
		var cut1 = f.GetComponentUnderTest<Wrapper>();
		var cut2 = f.GetComponentUnderTest<Wrapper>();

		Assert.True(ReferenceEquals(cut1, cut2), "Getting CUT multiple times should return the same instance");
		Assert.Equal("CUT", cut1.Markup);

		var firstFragmentNoId1 = f.GetFragment();
		var firstFragmentId1 = f.GetFragment("first");
		var firstFragmentNoId2 = f.GetFragment();
		var firstFragmentId2 = f.GetFragment("first");
		Assert.True(ReferenceEquals(firstFragmentNoId1, firstFragmentId1), "Getting first fragment with and without id should return the same instance");
		Assert.True(ReferenceEquals(firstFragmentNoId1, firstFragmentNoId2), "Getting first fragment multiple times should return the same instance");
		Assert.True(ReferenceEquals(firstFragmentId1, firstFragmentId2), "Getting first fragment multiple times should return the same instance");
		Assert.Equal("first", firstFragmentNoId1.Markup);

		var secondFragmentId1 = f.GetFragment<Wrapper>("second");
		var secondFragmentId2 = f.GetFragment<Wrapper>("second");

		Assert.True(ReferenceEquals(secondFragmentId1, secondFragmentId2), "Getting fragment multiple times should return the same instance");
		Assert.Equal("second", secondFragmentId2.Markup);
	}
}

<Fixture Test="CallingGenericGetAfterNonGenericGetThrows">
	<ComponentUnderTest>
		<Wrapper>CUT</Wrapper>
	</ComponentUnderTest>
	<Fragment>
		<Wrapper>second</Wrapper>
	</Fragment>
</Fixture>
@code{
	void CallingGenericGetAfterNonGenericGetThrows(Fixture f)
	{
		f.GetComponentUnderTest();

		// It should not be possible to call the generic GetComponentUnderTest after the non-generic has been called
		Assert.Throws<InvalidOperationException>(() => f.GetComponentUnderTest<Wrapper>());

		f.GetFragment();

		// It should not be possible to call the generic GetFragment after the non-generic has been called
		Assert.Throws<InvalidOperationException>(() => f.GetFragment<Wrapper>());
	}
}

<Fixture Test="CallingGetCutOrGetFragmentWithWrongGenericTypeThrows">
	<ComponentUnderTest>
		<Wrapper></Wrapper>
	</ComponentUnderTest>
	<Fragment>
		<Wrapper></Wrapper>
	</Fragment>
</Fixture>
@code{
	void CallingGetCutOrGetFragmentWithWrongGenericTypeThrows(Fixture f)
	{
		Assert.Throws<ComponentNotFoundException>(() => f.GetComponentUnderTest<Simple1>());
		Assert.Throws<ComponentNotFoundException>(() => f.GetFragment<Simple1>());
	}
}

<Fixture Test="CallingGetCutOrGetFragmentWithIncompatibleGenericTypeThrows">
	<ComponentUnderTest>
		<Wrapper></Wrapper>
	</ComponentUnderTest>
	<Fragment>
		<Wrapper></Wrapper>
	</Fragment>
</Fixture>
@code{
	void CallingGetCutOrGetFragmentWithIncompatibleGenericTypeThrows(Fixture f)
	{
		f.GetComponentUnderTest<Wrapper>();
		f.GetFragment<Wrapper>();
		Assert.Throws<InvalidOperationException>(() => f.GetComponentUnderTest<Simple1>());
		Assert.Throws<InvalidOperationException>(() => f.GetFragment<Simple1>());
	}
}
